#!/usr/bin/env python3
"""
tsv_to_testscript.py

TSV Format:
Column A is where the number is,
Column B is where the code is,
Column C is the expected output,
Column D is the actual output and
Column E is the test result
"""

from __future__ import annotations

import csv
import os
import re
from pathlib import Path
from typing import Any, Dict, List, Optional


# =========================
# Config (edit these)
# =========================

# ---- Bulletproof project-root anchoring (ignores `cd`) ----
# This file is expected to live at:
#   <project_root>/static/python/app/utils/tsv_to_testscript.py
# So:
#   parents[0] = .../app/utils
#   parents[1] = .../app
#   parents[2] = .../python
#   parents[3] = .../static
#   parents[4] = <project_root>
PROJECT_ROOT = Path(__file__).resolve().parents[4]

# Where to traverse for the TSV (set to the folder that contains testscripts.tsv)
ROOT_DIR = PROJECT_ROOT / "static/python/app/utils/sources"

TSV_FILENAME = "testscripts.tsv"    # TSV to search for
OUTPUT_FILENAME = "syntax_tscripts.py"   # Name of generated file
LIST_NAME = "SYNTAX_TSCRIPTS"

# Where to generate the output file (your parser package folder)
OUTPUT_DIR = PROJECT_ROOT / "static/python/tests"

TSV_DELIMITER = "\t"
ENCODING = "utf-8-sig"              # safer for TSV exported from Excel


# =========================
# Helpers
# =========================
def parse_bool(value: str) -> bool:
    v = (value or "").strip().lower()
    return v in {"true", "t", "yes", "y", "1"}


def format_code(raw: str) -> str:
    s = (raw or "").replace("\r\n", "\n").replace("\r", "\n")

    # If it's a single line and indentation is encoded as long spaces, convert.
    if "\n" not in s:
        def repl(m: re.Match) -> str:
            spaces = len(m.group(0))
            indent_levels = max(1, spaces // 5)
            return "\n" + ("    " * indent_levels)

        s = re.sub(r" {5,}", repl, s)

    s = re.sub(r";\s*}", ";\n}", s)
    s = re.sub(r"\s+}\s*$", "\n}", s)

    return s.strip()


def py_triple_quote(s: str) -> str:
    s = s.replace('"""', r'\"\"\"')
    return f'"""{s}"""'


def row_to_testdict(row: List[str]) -> Optional[Dict[str, Any]]:
    if not row or all(not (c or "").strip() for c in row):
        return None

    while len(row) < 5:
        row.append("")

    num_str, code, expected, actual, result = row[:5]

    # Skip header-like rows
    if (num_str or "").strip().lower() in {"number", "no", "#"}:
        return None

    try:
        number = int(num_str.strip())
    except ValueError:
        return None

    return {
        "number": number,
        "actual_output": actual.strip(),
        "expected_output": expected.strip(),
        "test_result": parse_bool(result),
        "code": format_code(code),
    }


def write_testscript_py(
    tsv_path: Path,
    list_name: str,
    tests: List[Dict[str, Any]],
) -> Path:
    # Decide output directory
    if OUTPUT_DIR is None:
        out_dir = tsv_path.parent
    else:
        out_dir = Path(OUTPUT_DIR)  # OUTPUT_DIR may already be a Path
        out_dir.mkdir(parents=True, exist_ok=True)

    out_path = out_dir / OUTPUT_FILENAME

    lines: List[str] = []
    lines.append("# Auto-generated by tsv_to_testscript.py")
    lines.append("# Do not edit manually.\n")
    lines.append(f"{list_name} = [")

    for t in tests:
        lines.append("  {")
        lines.append(f'    "number": {t["number"]},')
        lines.append(f'    "actual_output": {t["actual_output"]!r},')
        lines.append(f'    "expected_output": {t["expected_output"]!r},')
        lines.append(f'    "test_result": {t["test_result"]},')
        lines.append('    "code":')
        lines.append(f"    {py_triple_quote(t['code'])}")
        lines.append("  },")
    lines.append("]\n")

    out_path.write_text("\n".join(lines), encoding="utf-8")
    return out_path


def find_tsv_files(root_dir: Path, tsv_filename: str) -> List[Path]:
    matches: List[Path] = []
    for dirpath, _, filenames in os.walk(root_dir):
        if tsv_filename in filenames:
            matches.append(Path(dirpath) / tsv_filename)
    return matches


# =========================
# Main
# =========================
def main() -> int:
    root = Path(ROOT_DIR)
    if not root.exists():
        print(f"[ERROR] ROOT_DIR does not exist: {root}")
        print(f"[DEBUG] PROJECT_ROOT resolved as: {PROJECT_ROOT}")
        return 2

    tsv_paths = find_tsv_files(root, TSV_FILENAME)
    if not tsv_paths:
        print(f"[ERROR] No TSV named '{TSV_FILENAME}' found under: {root}")
        return 3

    for tsv_path in tsv_paths:
        tests: List[Dict[str, Any]] = []
        with tsv_path.open("r", encoding=ENCODING, newline="") as f:
            reader = csv.reader(f, delimiter=TSV_DELIMITER)
            next(reader, None)  # skip header

            for row in reader:
                td = row_to_testdict(row)
                if td:
                    tests.append(td)

        out_path = write_testscript_py(tsv_path, LIST_NAME, tests)
        print(f"[OK] Read {tsv_path} -> wrote {len(tests)} tests -> {out_path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
